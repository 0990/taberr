package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path"
	"path/filepath"

	"github.com/davyxu/pbmeta"
	"github.com/davyxu/tabtoy/data"
	"github.com/davyxu/tabtoy/filter"
	"github.com/davyxu/tabtoy/printer"
	"github.com/davyxu/tabtoy/scanner"
)

///////////////////////////////////////////////
// mode: xls2pbt参数
///////////////////////////////////////////////

// 输入协议二进制描述文件,通过protoc配合github.com/davyxu/pbmeta/protoc-gen-meta插件导出
var paramPbFile = flag.String("pb", "PB", "input protobuf binary descript file, export by protoc-gen-meta plugins")

// 输入电子表格文件
var paramXlsFile = flag.String("xls", "XLS", "input excel file, use ',' splited file list by multipy files")

// 输出文件夹
var paramOutDir = flag.String("outdir", "OUT_DIR", "output directory")

func runXls2PbtMode() bool {
	// 输入协议二进制描述文件,通过protoc配合github.com/davyxu/pbmeta/protoc-gen-meta插件导出
	fds, err := pbmeta.LoadFileDescriptorSet(*paramPbFile)
	if err != nil {
		fmt.Println(err)
		return false
	}

	// 创建描述文件池
	pool := pbmeta.NewDescriptorPool(fds)

	return parallelWorker(flag.Args(), *paramPara, *paramOutDir, func(input, output string) bool {

		return export(pool, input, output)

	})

	return true
}

// 封装signal返回, 因为go关键字会忽略函数返回值, 所以用channel来传递结果
func task(input, output string, callback func(string, string) bool, signal chan bool) bool {

	result := callback(input, output)

	if signal != nil {
		signal <- result
		return result
	}

	return result
}

func parallelWorker(fileList []string, para bool, outDir string, callback func(string, string) bool) bool {

	// 处理多个导出文件情况

	var signal chan bool

	if para {
		signal = make(chan bool)
	}

	for _, v := range fileList {
		inputFile := v

		// 使用指定的导出文件夹,并更换电子表格输入文件的后缀名为pbt作为输出文件
		outputFile := path.Join(outDir, changeFileExt(inputFile, ".pbt"))

		if signal != nil {
			go task(inputFile, outputFile, callback, signal)
		} else {

			if !task(inputFile, outputFile, callback, signal) {

				return false
			}
		}

	}

	// 并发导出同步
	if signal != nil {
		for i := 0; i < len(fileList); i++ {
			result := <-signal
			if !result {

				return false
			}
		}
	}

	return true
}

func setFieldValue(ri *scanner.RecordInfo, fieldName, value string) bool {

	// 转换电子表格的原始值到msg可接受的值
	if afterValue, ok := filter.ValueConvetor(ri.FieldDesc, value); ok {

		fd := ri.FieldMsg.Desc.FieldByName(fieldName)

		if fd == nil {
			log.Errorf("field not exist: %s=%s", fieldName, value)
			return false
		}

		if data.DebuggingLevel >= 2 {
			log.Debugf("	%s=%s", fd.Name(), afterValue)
		}

		// 多值
		if fd.IsRepeated() {
			ri.FieldMsg.AddRepeatedValue(fd, afterValue)

		} else {

			// 单值
			ri.FieldMsg.SetValue(fd, afterValue)
		}

	} else {
		log.Errorf("value convert error: %s=%s", fieldName, value)
		return false
	}

	return true
}

func export(pool *pbmeta.DescriptorPool, inputXls, outputFile string) bool {

	// 显示电子表格到导出文件
	log.Infof("%s -> %s\n", filepath.Base(inputXls), filepath.Base(outputFile))

	// 打开电子表格
	xlsFile := scanner.NewFile(pool)

	if !xlsFile.Open(inputXls) {
		return false
	}

	var outBuff bytes.Buffer

	// 遍历所有表格sheet
	for _, sheet := range xlsFile.Sheets {

		repChecker := filter.NewRepeatValueChecker()

		// 遍历表格的所有行/列
		fileMsg, ok := sheet.IterateData(func(ri *scanner.RecordInfo) bool {

			// 重复值检查
			repChecker.Check(ri.FieldMeta, ri.FieldDesc, ri.Value)

			// 字符串转结构体
			if filter.Value2Struct(ri.FieldMeta, ri.Value, func(key, value string) {

				setFieldValue(ri, key, value)
			}) {
				return true
			}

			// 分隔符切分值
			if filter.Value2List(ri.FieldMeta, ri.Value, func(value string) {
				setFieldValue(ri, ri.FieldDesc.Name(), value)
			}) {
				return true
			}

			return setFieldValue(ri, ri.FieldDesc.Name(), ri.Value)

		})

		if !ok {
			return false
		}

		if fileMsg != nil {
			// 显示导出Sheet时的名称
			log.Infof("	%s", sheet.Name)
			outBuff.WriteString(printer.WriteProtoBufferText(fileMsg))
		}

	}

	// 创建输出文件
	file, err := os.Create(outputFile)
	if err != nil {
		log.Errorln(err.Error())
		return false
	}

	// 写入文件头
	file.WriteString(fmt.Sprintf("# Generated by github.com/davyxu/tabtoy\n"))
	file.WriteString(outBuff.String())

	file.Close()

	return true
}
