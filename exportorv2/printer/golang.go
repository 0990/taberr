package printer

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/printer"
	"go/token"
	"text/template"

	"github.com/davyxu/tabtoy/exportorv2/i18n"
	"github.com/davyxu/tabtoy/exportorv2/model"
)

const goTemplate = `// Generated by github.com/davyxu/tabtoy
// Version: {{.ToolVersion}}
// DO NOT EDIT!!
package {{.Package}}

import(	
	{{if .HasAnyIndex}}"fmt"{{end}}
)
{{range $a, $en := .Enums}} 
type {{$en.Name}} int32
const (	
{{range .GoFields}}
	{{.Comment}}
	{{$en.Name}}_{{.Name}} {{$en.Name}} = {{.Number}}
{{end}}
)
{{end}}

{{range $a, $strus := .Structs}} 
type {{$strus.Name}} struct{
	{{range $b, $fd := $strus.GoFields}} 
	{{.Comment}}
	{{$fd.Name}} {{$fd.TypeString}} {{$fd.StructTag}}
	{{end}}
}
{{end}}


{{range $a, $strus := .IndexedStructs}} {{range .Indexes}}
var {{$strus.Name}}By{{.Name}} = make(map[{{.KeyType}}]*{{$strus.TypeName}})
{{end}} {{end}}
func init() {
	
	{{range $a, $strus := .IndexedStructs}}
	
	RegisterIndexEntry("{{$strus.Name}}", func( content interface{} ){
		
		config := content.(*{{$.Name}})
		
		// {{$strus.Name}}
		for _, def := range config.{{$strus.Name}} {
			{{range .Indexes}}
			if _, ok := {{$strus.Name}}By{{.Name}}[def.{{.Name}}]; ok {
				panic(fmt.Sprintf("duplicate index in {{$strus.Name}}By{{.Name}}: %v", def.{{.Name}}))
			}
			{{end}}		
			{{range .Indexes}}
			{{$strus.Name}}By{{.Name}}[def.{{.Name}}] = def{{end}}
			
		}
		
	}){{end}}
}

`

// 每个带有MakeIndex的列
type goFieldModel struct {
	*model.FieldDescriptor
	Number int
}

func (self goFieldModel) Comment() string {

	var out string

	if self.FieldDescriptor.Meta.GetString("Alias") == "" {
		out += "// "
		out += self.FieldDescriptor.Meta.GetString("Alias")
	}

	if self.FieldDescriptor.Comment != "" {
		if out == "" {
			out += "//"
		}
		out += self.FieldDescriptor.Comment
	}

	return out

}

func (self *goFieldModel) KeyType() string {

	if self.Type == model.FieldType_Enum {
		return fmt.Sprintf("%s.%s", self.FieldDescriptor.Parent.File.Pragma.GetString("Package"), self.Complex.Name)
	}

	return model.FieldTypeToString(self.Type)
}

func (self *goFieldModel) StructTag() string {

	var buf bytes.Buffer

	buf.WriteString("`")

	var userTagCount int

	self.Meta.VisitUserMeta(func(k string, v interface{}) bool {

		if userTagCount > 0 {
			buf.WriteString(" ")
		}

		buf.WriteString(fmt.Sprintf("%s:\"%s\"", k, v))

		userTagCount++

		return true
	})

	buf.WriteString("`")

	if userTagCount == 0 {
		return ""
	}

	return buf.String()
}

func (self *goFieldModel) TypeString() string {

	var prefix string
	if self.IsRepeated {
		prefix = "[]"
	}

	switch self.FieldDescriptor.Type {
	case model.FieldType_Float:
		return prefix + "float32"
	case model.FieldType_Struct:
		return prefix + "*" + self.FieldDescriptor.TypeString()
	default:
		return prefix + self.FieldDescriptor.TypeString()
	}

}

// 对应每个电子表格文件
type goIndexStructModel struct {
	*model.FieldDescriptor

	Indexes []*goFieldModel
}

func (self *goIndexStructModel) TypeName() string {
	return self.Complex.Name
}

type goStructModel struct {
	*model.Descriptor

	GoFields []*goFieldModel
}

// 整个导出文件
type goFileModel struct {
	*model.FileDescriptor
	ToolVersion    string
	IndexedStructs []*goIndexStructModel
	Structs        []*goStructModel
	Enums          []*goStructModel
	IndexCount     int
	ImportPackage  string
}

func (self *goFileModel) HasAnyIndex() bool {
	return self.IndexCount > 0
}

func (self *goFileModel) HasAnyStruct() bool {
	return len(self.Structs) > 0
}

func (self *goFileModel) Package() string {
	return self.FileDescriptor.Pragma.GetString("Package")
}

type goPrinter struct {
}

func collectIndexInfo(g *Globals, fm *goFileModel) {

	// 遍历需要导出的合并字段
	for _, fd := range g.CombineStruct.Fields {

		// fd --> 对应每个文件的Row定义, 也就是XXDefine, 在CombineStruct上, 只是一个字段

		// 对CombineStruct的XXDefine对应的字段
		if g.CombineStruct.Usage != model.DescriptorUsage_CombineStruct {
			continue
		}

		//非结构体不输出(其实根本不会击中)
		if fd.Complex == nil {
			continue
		}

		// 这个字段被限制输出
		if !fd.Complex.File.MatchTag(".go") {
			continue
		}

		// 这个结构有索引才创建
		if len(fd.Complex.Indexes) == 0 {
			continue
		}

		rm := goIndexStructModel{FieldDescriptor: fd}

		// 索引字段
		for _, key := range fd.Complex.Indexes {

			rm.Indexes = append(rm.Indexes, &goFieldModel{
				FieldDescriptor: key,
			})
			fm.IndexCount++
		}

		fm.IndexedStructs = append(fm.IndexedStructs, &rm)

	}
}

func collectAllStructInfo(g *Globals, fm *goFileModel) {

	// 遍历所有类型
	for _, d := range g.FileDescriptor.Descriptors {

		// 这给被限制输出
		if !d.File.MatchTag(".go") {
			log.Infof("%s: %s", i18n.String(i18n.Printer_IgnoredByOutputTag), d.Name)
			continue
		}

		structM := &goStructModel{Descriptor: d}

		// 遍历字段
		for index, fd := range d.Fields {

			// 对CombineStruct的XXDefine对应的字段
			if d.Usage == model.DescriptorUsage_CombineStruct {

				// 这个字段被限制输出
				if fd.Complex != nil && !fd.Complex.File.MatchTag(".go") {
					continue
				}
			}

			field := &goFieldModel{FieldDescriptor: fd}

			switch d.Kind {
			case model.DescriptorKind_Struct:
				field.Number = index + 1
			case model.DescriptorKind_Enum:
				field.Number = int(fd.EnumValue)
			}

			structM.GoFields = append(structM.GoFields, field)

		}

		switch d.Kind {
		case model.DescriptorKind_Struct:
			fm.Structs = append(fm.Structs, structM)
		case model.DescriptorKind_Enum:
			fm.Enums = append(fm.Enums, structM)
		}

	}
}

func (self *goPrinter) Run(g *Globals) *BinaryFile {

	tpl, err := template.New("golang").Parse(goTemplate)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	var fm goFileModel
	fm.ToolVersion = g.Version
	fm.FileDescriptor = g.FileDescriptor
	fm.ImportPackage = g.GoImportPackage

	collectIndexInfo(g, &fm)
	collectAllStructInfo(g, &fm)

	bf := NewBinaryFile()

	err = tpl.Execute(bf.Buffer(), &fm)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	if err := formatCode(bf.Buffer()); err != nil {
		log.Errorln("format golang code err", err)
	}

	return bf
}

func formatCode(bf *bytes.Buffer) error {

	fset := token.NewFileSet()

	ast, err := parser.ParseFile(fset, "", bf, parser.ParseComments)
	if err != nil {
		return err
	}

	bf.Reset()

	err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(bf, fset, ast)
	if err != nil {
		return err
	}

	return nil
}

func init() {

	RegisterPrinter("go", &goPrinter{})

}
