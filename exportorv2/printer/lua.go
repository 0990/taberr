package printer

import (
	"fmt"

	"github.com/davyxu/tabtoy/exportorv2/model"
	"github.com/davyxu/tabtoy/util"
)

func valueWrapperLua(t model.FieldType, n *model.Node) string {

	switch t {
	case model.FieldType_String:
		return util.StringEscape(n.Value)
	case model.FieldType_Enum:
		return fmt.Sprintf("\"%s\"", n.Value)
	}

	return n.Value
}

func PrintLua(tab *model.Table, rootName string, version string, outfile string) bool {

	bf := NewBinaryFile(rootName)

	bf.Printf("-- Generated by github.com/davyxu/tabtoy\n")
	bf.Printf("-- Version: %s\n", version)

	bf.Printf("\nlocal tab = {\n")

	bf.Printf("	%s = {\n", rootName)

	// 遍历每一行
	for rIndex, r := range tab.Recs {

		// 每一行开始
		bf.Printf("		{ ")

		// 遍历每一列
		for rootFieldIndex, node := range r.Nodes {

			if node.IsRepeated {
				bf.Printf("%s = { ", node.Name)
			} else {
				bf.Printf("%s = ", node.Name)
			}

			// 普通值
			if node.Type != model.FieldType_Struct {

				if node.IsRepeated {

					// repeated 值序列
					for arrIndex, valueNode := range node.Child {

						bf.Printf("%s", valueWrapperLua(node.Type, valueNode))

						// 多个值分割
						if arrIndex < len(node.Child)-1 {
							bf.Printf(", ")
						}

					}
				} else {
					// 单值
					valueNode := node.Child[0]

					bf.Printf("%s", valueWrapperLua(node.Type, valueNode))

				}

			} else {

				// 遍历repeated的结构体
				for structIndex, structNode := range node.Child {

					// 结构体开始
					bf.Printf("{ ")

					// 遍历一个结构体的字段
					for structFieldIndex, fieldNode := range structNode.Child {

						// 值节点总是在第一个
						valueNode := fieldNode.Child[0]

						bf.Printf("%s= %s", fieldNode.Name, valueWrapperLua(fieldNode.Type, valueNode))

						// 结构体字段分割
						if structFieldIndex < len(structNode.Child)-1 {
							bf.Printf(", ")
						}

					}

					// 结构体结束
					bf.Printf(" }")

					// 多个结构体分割
					if structIndex < len(node.Child)-1 {
						bf.Printf(", ")
					}

				}

			}

			if node.IsRepeated {
				bf.Printf(" }")
			}

			// 根字段分割
			if rootFieldIndex < len(r.Nodes)-1 {
				bf.Printf(", ")
			}

		}

		// 每一行结束
		bf.Printf(" 	}")

		if rIndex < len(tab.Recs)-1 {
			bf.Printf(",")
		}

		bf.Printf("\n")

	}

	// Sample = {
	bf.Printf("	}\n\n")

	// local tab = {
	bf.Printf("}\n\n")

	arr, ok := collectLuaIndex(tab)

	if !ok {
		return false
	}

	for _, fd := range arr {

		mapperVarName := fmt.Sprintf("tab.%sBy%s", rootName, fd.Name)

		bf.Printf("\n-- %s\n", fd.Name)
		bf.Printf("%s = {}\n", mapperVarName)
		bf.Printf("for _, rec in pairs(tab.%s) do\n", rootName)
		bf.Printf("\t%s[rec.%s] = rec\n", mapperVarName, fd.Name)
		bf.Printf("end\n")
	}

	bf.Printf("\nreturn tab")

	return bf.Write(outfile)

}

// 收集需要构建的索引的类型
func collectLuaIndex(tab *model.Table) (ret []*model.FieldDefine, ok bool) {

	if len(tab.Recs) == 0 {
		return
	}

	// 遍历每一列
	for _, node := range tab.Recs[0].Nodes {

		if node.Meta.LuaIndex {

			if node.BuildInType != nil {
				log.Errorf("lua can only support primitive type as index, ", node.String())
				return
			}

			ret = append(ret, node.FieldDefine)

		}
	}

	ok = true
	return
}
