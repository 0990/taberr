package printer

import (
	"fmt"
	"text/template"

	"github.com/davyxu/tabtoy/exportorv2/model"
)

// TODO pbmeta解析换rune的lexer [tabtoy] {{.Comment}}
const csharpTemplate = `// Generated by github.com/davyxu/tabtoy
// Version: {{.ToolVersion}}
// DO NOT EDIT!!
using System.Collections.Generic;
using System.IO;

namespace {{.Namespace}}
{
	{{range .Enums}}
	public enum {{.Name}}
	{
	{{range .Fields}}	
		// {{.Comment}}
		{{.FieldDefine.Name}} = {{.FieldDefine.EnumValue}},
	{{end}}
	}
	{{end}}
	{{range .Classes}}
	public partial class {{.Name}} : tabtoy.DataObject
	{	
	{{range .Fields}}	
		// {{.Comment}}
		{{.TypeCode}}
	{{end}}
		public void Deserialize( tabtoy.DataReader reader )
		{
			{{range .Fields}}
			// {{.Comment}}
			if ( reader.MatchTag({{.Tag}}))
			{
				{{.ReadCode}}
			}
			{{end}}
		}
	}
	{{end}}

}
`

const repeatedStructDeserializeCode = `{
				var c = reader.ReadInt32();
                for( int i = 0; i< c ; i++ )
				{
			    	var element = new %s();
			    	element.Deserialize(reader);
			
			    	this.%s.Add(element);
				}
			}
`

const repeatedPrimitiveDeserializeCode = `{
				var c = reader.ReadInt32();
                for( int i = 0; i< c ; i++ )
				{
			    	var element = %s;			    	
			
			    	this.%s.Add(element);
				}
			}
`

type csharpField struct {
	*model.FieldDefine
}

func (self csharpField) ReadCode() string {

	var baseType string

	switch self.Type {
	case model.FieldType_Int32:
		baseType = "Int32"
	case model.FieldType_UInt32:
		baseType = "UInt32"
	case model.FieldType_Int64:
		baseType = "Int64"
	case model.FieldType_UInt64:
		baseType = "UInt64"
	case model.FieldType_String:
		baseType = "String"
	case model.FieldType_Float:
		baseType = "Float"
	case model.FieldType_Bool:
		baseType = "Bool"
	case model.FieldType_Enum:

		if self.BuildInType == nil {
			return "unknown"
		}

		baseType = fmt.Sprintf("Enum<%s>", self.BuildInType.Name)

	case model.FieldType_Struct:
		if self.BuildInType == nil {
			return "unknown"
		}

		baseType = fmt.Sprintf("Struct<%s>", self.BuildInType.Name)

	}

	if self.IsRepeated {
		return fmt.Sprintf("reader.ReadList_%s( this.%s );", baseType, self.Name)
	} else {
		return fmt.Sprintf("this.%s = reader.Read%s( );", self.Name, baseType)
	}

}

func (self csharpField) Tag() string {

	return fmt.Sprintf("0x%x", self.FieldDefine.Tag())
}

func (self csharpField) TypeCode() string {

	var raw string

	switch self.Type {
	case model.FieldType_Int32:
		raw = "int"
	case model.FieldType_UInt32:
		raw = "uint"
	case model.FieldType_Int64:
		raw = "long"
	case model.FieldType_UInt64:
		raw = "ulong"
	case model.FieldType_String:
		raw = "string"
	case model.FieldType_Float:
		raw = "float"
	case model.FieldType_Bool:
		raw = "bool"
	case model.FieldType_Enum:
		if self.BuildInType == nil {
			log.Errorln("unknown enum type ", self.Type)
			return "unknown"
		}

		raw = self.BuildInType.Name
	case model.FieldType_Struct:
		if self.BuildInType == nil {
			log.Errorln("unknown struct type ", self.Type)
			return "unknown"
		}

		raw = self.BuildInType.Name

		// 非repeated的结构体
		if !self.IsRepeated {
			return fmt.Sprintf("public %s %s = new %s();", raw, self.Name, raw)
		}

	default:
		raw = "unknown"
	}

	if self.IsRepeated {
		return fmt.Sprintf("public List<%s> %s = new List<%s>();", raw, self.Name, raw)
	}

	return fmt.Sprintf("public %s %s = %s;", raw, self.Name, wrapCSharpDefaultValue(self.FieldDefine))
}

func wrapCSharpDefaultValue(fd *model.FieldDefine) string {
	switch fd.Type {
	case model.FieldType_Enum:
		return fmt.Sprintf("%s.%s", fd.BuildInType.Name, fd.DefaultValue())
	case model.FieldType_String:
		return fmt.Sprintf("\"%s\"", fd.DefaultValue())
	}

	return fd.DefaultValue()
}

type structModel struct {
	Name   string
	Fields []csharpField
}

type csharpFileModel struct {
	Namespace   string
	ToolVersion string
	Classes     []*structModel
	Enums       []*structModel
}

func PrintCSharp(ts *model.BuildInTypeSet, toolVersion string) *BinaryFile {

	tpl, err := template.New("csharp").Parse(csharpTemplate)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	var m csharpFileModel

	m.Namespace = ts.Pragma.Package
	m.ToolVersion = toolVersion

	// 遍历所有类型
	for _, bt := range ts.Types {

		if bt.RootFile {
			continue
		}

		var sm structModel
		sm.Name = bt.Name

		switch bt.Kind {
		case model.BuildInTypeKind_Struct:
			m.Classes = append(m.Classes, &sm)
		case model.BuildInTypeKind_Enum:
			m.Enums = append(m.Enums, &sm)
		}

		// 遍历字段
		for _, fd := range bt.Fields {

			sm.Fields = append(sm.Fields, csharpField{FieldDefine: fd})

		}

	}

	bf := NewBinaryFile("C# Source")

	err = tpl.Execute(bf.Buffer(), &m)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	return bf
}
