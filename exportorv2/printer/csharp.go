package printer

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/davyxu/tabtoy/exportorv2/model"
)

// TODO pbmeta解析换rune的lexer [tabtoy] {{.Comment}}
const csharpTemplate = `// Generated by github.com/davyxu/tabtoy
// Version: {{.ToolVersion}}
// DO NOT EDIT!!
using System.Collections.Generic;
using System.IO;
using tabtoy;

namespace {{.Namespace}}
{
	{{range .Enums}}
	public enum {{.Name}}
	{
	{{range .Fields}}	
		// {{.Comment}}
		{{.FieldDefine.Name}} = {{.FieldDefine.EnumValue}},
	{{end}}
	}
	{{end}}
	{{range .Classes}}
	public partial class {{.Name}}
	{	
	{{range .Fields}}	
		// {{.Comment}}
		{{.TypeCode}}
	{{end}}
		public void Deserialize( DataReader reader )
		{
			{{range .Fields}}	
			// {{.Comment}}
			{{.ReadCode}}
			{{end}}
		}
	}
	{{end}}

}
`

const structDeserialize = `{
			    var element = new %s();
			    element.Deserialize(reader);
			
			    this.%s.Add(element);
			}
`

type csharpField struct {
	*model.FieldDefine
}

func (self csharpField) ReadCode() string {

	var baseReadCode string

	switch self.Type {
	case model.FieldType_Int32:
		baseReadCode = "reader.ReadInt32()"
	case model.FieldType_UInt32:
		baseReadCode = "reader.ReadUInt32()"
	case model.FieldType_Int64:
		baseReadCode = "reader.ReadInt64()"
	case model.FieldType_UInt64:
		baseReadCode = "reader.ReadUInt64()"
	case model.FieldType_String:
		baseReadCode = "reader.ReadUTF8String()"
	case model.FieldType_Float:
		baseReadCode = "reader.ReadSingle()"
	case model.FieldType_Bool:
		baseReadCode = "reader.ReadBoolean()"
	case model.FieldType_Enum:

		if self.BuildInType == nil {
			return "unknown"
		}

		baseReadCode = fmt.Sprintf("(%s)reader.ReadInt32()", self.BuildInType.Name)

	case model.FieldType_Struct:
		if self.BuildInType == nil {
			return "unknown"
		}

		return fmt.Sprintf(structDeserialize, self.BuildInType.Name, self.Name)

	}

	if self.IsRepeated {
		return fmt.Sprintf("this.%s.Add( %s );", self.Name, baseReadCode)
	} else {
		return fmt.Sprintf("this.%s = %s;", self.Name, baseReadCode)
	}

}

func (self csharpField) TypeCode() string {

	var raw string

	switch self.Type {
	case model.FieldType_Int32:
		raw = "int"
	case model.FieldType_UInt32:
		raw = "uint"
	case model.FieldType_Int64:
		raw = "long"
	case model.FieldType_UInt64:
		raw = "ulong"
	case model.FieldType_String:
		raw = "string"
	case model.FieldType_Float:
		raw = "float"
	case model.FieldType_Bool:
		raw = "bool"
	case model.FieldType_Enum,
		model.FieldType_Struct:
		if self.BuildInType == nil {
			log.Errorln("unknown type ", self.Type)
			return "unknown"
		}

		raw = self.BuildInType.Name
	default:
		raw = "unknown"
	}

	if self.IsRepeated {
		return fmt.Sprintf("public List<%s> %s = new List<%s>();", raw, self.Name, raw)
	}

	return fmt.Sprintf("public %s %s;", raw, self.Name)
}

type structModel struct {
	Name   string
	Fields []csharpField
}

type csharpFileModel struct {
	Namespace   string
	ToolVersion string
	Classes     []*structModel
	Enums       []*structModel
}

func PrintCSharp(ts *model.BuildInTypeSet, toolVersion string, outfile string) bool {

	tpl, err := template.New("csharp").Parse(csharpTemplate)
	if err != nil {
		log.Errorln(err)
		return false
	}

	var m csharpFileModel

	m.Namespace = ts.Pragma.Package
	m.ToolVersion = toolVersion

	// 遍历所有类型
	for _, bt := range ts.Types {

		var sm structModel
		sm.Name = bt.Name

		switch bt.Kind {
		case model.BuildInTypeKind_Struct:
			m.Classes = append(m.Classes, &sm)
		case model.BuildInTypeKind_Enum:
			m.Enums = append(m.Enums, &sm)
		}

		// 遍历字段
		// TODO 字段排序
		for _, fd := range bt.Fields {

			if strings.Index(fd.Name, "#") == 0 {
				continue
			}

			sm.Fields = append(sm.Fields, csharpField{FieldDefine: fd})

		}

	}

	var buf bytes.Buffer

	err = tpl.Execute(&buf, &m)
	if err != nil {
		log.Errorln(err)
		return false
	}

	ioutil.WriteFile(outfile, buf.Bytes(), 0666)

	return true
}
